<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/webtorrent/parse-torrent#readme"

    >parse-torrent (v5.8.3)</a>
</h1>
<h4>Parse a torrent identifier (magnet uri, .torrent file, info hash)</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.parse-torrent">module parse-torrent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parse-torrent.parse-torrent">
            function <span class="apidocSignatureSpan"></span>parse-torrent
            <span class="apidocSignatureSpan">(torrentId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parse-torrent.remote">
            function <span class="apidocSignatureSpan">parse-torrent.</span>remote
            <span class="apidocSignatureSpan">(torrentId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parse-torrent.toMagnetURI">
            function <span class="apidocSignatureSpan">parse-torrent.</span>toMagnetURI
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.parse-torrent.toTorrentFile">
            function <span class="apidocSignatureSpan">parse-torrent.</span>toTorrentFile
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.parse-torrent" id="apidoc.module.parse-torrent">module parse-torrent</a></h1>


    <h2>
        <a href="#apidoc.element.parse-torrent.parse-torrent" id="apidoc.element.parse-torrent.parse-torrent">
        function <span class="apidocSignatureSpan"></span>parse-torrent
        <span class="apidocSignatureSpan">(torrentId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseTorrent(torrentId) {
  if (typeof torrentId === &#x27;string&#x27; &#x26;&#x26; /^(stream-)?magnet:/.test(torrentId)) {
    // magnet uri (string)
    return magnet(torrentId)
  } else if (typeof torrentId === &#x27;string&#x27; &#x26;&#x26; (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
    // info hash (hex/base-32 string)
    return magnet(&#x27;magnet:?xt=urn:btih:&#x27; + torrentId)
  } else if (Buffer.isBuffer(torrentId) &#x26;&#x26; torrentId.length === 20) {
    // info hash (buffer)
    return magnet(&#x27;magnet:?xt=urn:btih:&#x27; + torrentId.toString(&#x27;hex&#x27;))
  } else if (Buffer.isBuffer(torrentId)) {
    // .torrent file (buffer)
    return parseTorrentFile(torrentId) // might throw
  } else if (torrentId &#x26;&#x26; torrentId.infoHash) {
    // parsed torrent (from `parse-torrent`, `parse-torrent-file`, or `magnet-uri`)
    if (!torrentId.announce) torrentId.announce = []
    if (typeof torrentId.announce === &#x27;string&#x27;) {
      torrentId.announce = [ torrentId.announce ]
    }
    if (!torrentId.urlList) torrentId.urlList = []
    return torrentId
  } else {
    throw new Error(&#x27;Invalid torrent identifier&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parse-torrent.remote" id="apidoc.element.parse-torrent.remote">
        function <span class="apidocSignatureSpan">parse-torrent.</span>remote
        <span class="apidocSignatureSpan">(torrentId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseTorrentRemote(torrentId, cb) {
  var parsedTorrent
  if (typeof cb !== &#x27;function&#x27;) throw new Error(&#x27;second argument must be a Function&#x27;)

  try {
    parsedTorrent = parseTorrent(torrentId)
  } catch (err) {
    // If torrent fails to parse, it could be a Blob, http/https URL or
    // filesystem path, so don&#x27;t consider it an error yet.
  }

  if (parsedTorrent &#x26;&#x26; parsedTorrent.infoHash) {
    process.nextTick(function () {
      cb(null, parsedTorrent)
    })
  } else if (isBlob(torrentId)) {
    blobToBuffer(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error(&#x27;Error converting Blob: &#x27; + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof get === &#x27;function&#x27; &#x26;&#x26; /^https?:/.test(torrentId)) {
    // http, or https url to torrent file
    get.concat({
      url: torrentId,
      timeout: 30 * 1000,
      headers: { &#x27;user-agent&#x27;: &#x27;WebTorrent (http://webtorrent.io)&#x27; }
    }, function (err, res, torrentBuf) {
      if (err) return cb(new Error(&#x27;Error downloading torrent: &#x27; + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof fs.readFile === &#x27;function&#x27; &#x26;&#x26; typeof torrentId === &#x27;string&#x27;) {
    // assume it&#x27;s a filesystem path
    fs.readFile(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error(&#x27;Invalid torrent identifier&#x27;))
      parseOrThrow(torrentBuf)
    })
  } else {
    process.nextTick(function () {
      cb(new Error(&#x27;Invalid torrent identifier&#x27;))
    })
  }

  function parseOrThrow (torrentBuf) {
    try {
      parsedTorrent = parseTorrent(torrentBuf)
    } catch (err) {
      return cb(err)
    }
    if (parsedTorrent &#x26;&#x26; parsedTorrent.infoHash) cb(null, parsedTorrent)
    else cb(new Error(&#x27;Invalid torrent identifier&#x27;))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### remote torrents

To support remote torrent identifiers (i.e. http/https links to .torrent files, or
filesystem paths), as well as Blobs use the `parseTorrent.remote` function. It takes
a callback since these torrent types require async operations:

```js
parseTorrent.<span class="apidocCodeKeywordSpan">remote</span>(torrentId, function (err, parsedTorrent) {
  if (err) throw err
  console.log(parsedTorrent)
})
```

### command line program
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parse-torrent.toMagnetURI" id="apidoc.element.parse-torrent.toMagnetURI">
        function <span class="apidocSignatureSpan">parse-torrent.</span>toMagnetURI
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function magnetURIEncode(obj) {
  obj = extend(obj) // clone obj, so we can mutate it

  // support using convenience names, in addition to spec names
  // (example: `infoHash` for `xt`, `name` for `dn`)
  if (obj.infoHashBuffer) obj.xt = &#x27;urn:btih:&#x27; + obj.infoHashBuffer.toString(&#x27;hex&#x27;)
  if (obj.infoHash) obj.xt = &#x27;urn:btih:&#x27; + obj.infoHash
  if (obj.name) obj.dn = obj.name
  if (obj.keywords) obj.kt = obj.keywords
  if (obj.announce) obj.tr = obj.announce
  if (obj.urlList) {
    obj.ws = obj.urlList
    delete obj.as
  }

  var result = &#x27;magnet:?&#x27;
  Object.keys(obj)
    .filter(function (key) {
      return key.length === 2
    })
    .forEach(function (key, i) {
      var values = Array.isArray(obj[key]) ? obj[key] : [ obj[key] ]
      values.forEach(function (val, j) {
        if ((i &#x3e; 0 || j &#x3e; 0) &#x26;&#x26; (key !== &#x27;kt&#x27; || j === 0)) result += &#x27;&#x26;&#x27;

        if (key === &#x27;dn&#x27;) val = encodeURIComponent(val).replace(/%20/g, &#x27;+&#x27;)
        if (key === &#x27;tr&#x27; || key === &#x27;xs&#x27; || key === &#x27;as&#x27; || key === &#x27;ws&#x27;) {
          val = encodeURIComponent(val)
        }
        if (key === &#x27;kt&#x27;) val = encodeURIComponent(val)

        if (key === &#x27;kt&#x27; &#x26;&#x26; j &#x3e; 0) result += &#x27;+&#x27; + val
        else result += key + &#x27;=&#x27; + val
      })
    })

  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The reverse works too. To convert an object of keys/value to a magnet uri or .torrent file
buffer, use `toMagnetURI` and `toTorrentFile`.

```js
var parseTorrent = require(&#x27;parse-torrent&#x27;)

var uri = parseTorrent.<span class="apidocCodeKeywordSpan">toMagnetURI</span>({
infoHash: &#x27;d2474e86c95b19b8bcfdb92bc12c9d44667cfa36&#x27;
})
console.log(uri) // &#x27;magnet:?xt=urn:btih:d2474e86c95b19b8bcfdb92bc12c9d44667cfa36&#x27;

var buf = parseTorrent.toTorrentFile({
info: {
  /* ... */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.parse-torrent.toTorrentFile" id="apidoc.element.parse-torrent.toTorrentFile">
        function <span class="apidocSignatureSpan">parse-torrent.</span>toTorrentFile
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeTorrentFile(parsed) {
  var torrent = {
    info: parsed.info
  }

  torrent[&#x27;announce-list&#x27;] = (parsed.announce || []).map(function (url) {
    if (!torrent.announce) torrent.announce = url
    url = new Buffer(url, &#x27;utf8&#x27;)
    return [ url ]
  })

  torrent[&#x27;url-list&#x27;] = parsed.urlList || []

  if (parsed.created) {
    torrent[&#x27;creation date&#x27;] = (parsed.created.getTime() / 1000) | 0
  }

  if (parsed.createdBy) {
    torrent[&#x27;created by&#x27;] = parsed.createdBy
  }

  if (parsed.comment) {
    torrent.comment = parsed.comment
  }

  return bencode.encode(torrent)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var parseTorrent = require(&#x27;parse-torrent&#x27;)

var uri = parseTorrent.toMagnetURI({
  infoHash: &#x27;d2474e86c95b19b8bcfdb92bc12c9d44667cfa36&#x27;
})
console.log(uri) // &#x27;magnet:?xt=urn:btih:d2474e86c95b19b8bcfdb92bc12c9d44667cfa36&#x27;

var buf = parseTorrent.<span class="apidocCodeKeywordSpan">toTorrentFile</span>({
  info: {
    /* ... */
  }
})
console.log(buf)
```
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
